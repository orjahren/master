diff --git a/srunner/scenarios/follow_leading_vehicle.py b/srunner/scenarios/follow_leading_vehicle.py
index 5f60061..2117eae 100644
--- a/srunner/scenarios/follow_leading_vehicle.py
+++ b/srunner/scenarios/follow_leading_vehicle.py
@@ -6,14 +6,19 @@
 # For a copy, see <https://opensource.org/licenses/MIT>.
 
 """
-Follow leading vehicle scenario:
+Enhanced Follow leading vehicle scenario:
 
 The scenario realizes a common driving behavior, in which the
 user-controlled ego vehicle follows a leading car driving down
-a given road. At some point the leading car has to slow down and
+a given road. This enhanced version introduces more complexity:
+1. A pedestrian crosses the road in front of the leading vehicle, forcing it
+   to react and slow down/stop unexpectedly.
+2. A parked vehicle partially obstructs the road near the final stopping point,
+   decreasing visibility and narrowing the path.
+At some point, the leading car has to slow down and
 finally stop. The ego vehicle has to react accordingly to avoid
-a collision. The scenario ends either via a timeout, or if the ego
-vehicle stopped close enough to the leading vehicle
+a collision and navigate the increased complexity. The scenario ends either via a timeout, or if the ego
+vehicle stopped close enough to the leading vehicle.
 """
 
 import random
@@ -27,7 +32,8 @@ from srunner.scenariomanager.scenarioatomics.atomic_behaviors import (ActorTrans
                                                                       ActorDestroy,
                                                                       KeepVelocity,
                                                                       StopVehicle,
-                                                                      WaypointFollower)
+                                                                      WaypointFollower,
+                                                                      WalkToLocation)
 from srunner.scenariomanager.scenarioatomics.atomic_criteria import CollisionTest
 from srunner.scenariomanager.scenarioatomics.atomic_trigger_conditions import (InTriggerDistanceToVehicle,
                                                                                InTriggerDistanceToNextIntersection,
@@ -41,13 +47,13 @@ from srunner.tools.scenario_helper import get_waypoint_in_distance
 class FollowLeadingVehicle(BasicScenario):
 
     """
-    This class holds everything required for a simple "Follow a leading vehicle"
-    scenario involving two vehicles.  (Traffic Scenario 2)
+    This class holds everything required for a complex "Follow a leading vehicle"
+    scenario involving two vehicles, a pedestrian, and a parked car. (Traffic Scenario 2)
 
-    This is a single ego vehicle scenario
+    This is a single ego vehicle scenario, with enhanced complexity.
     """
 
-    timeout = 120            # Timeout of scenario in seconds
+    timeout = 180            # Increased timeout of scenario in seconds for more complexity
 
     def __init__(self, world, ego_vehicles, config, randomize=False, debug_mode=False, criteria_enable=True,
                  timeout=60):
@@ -58,16 +64,22 @@ class FollowLeadingVehicle(BasicScenario):
         """
 
         self._map = CarlaDataProvider.get_map()
-        self._first_vehicle_location = 25
+        self._first_vehicle_location = 25 # Distance of leading vehicle from ego's trigger point
         self._first_vehicle_speed = 10
         self._reference_waypoint = self._map.get_waypoint(config.trigger_points[0].location)
         self._other_actor_max_brake = 1.0
-        self._other_actor_stop_in_front_intersection = 20
-        self._other_actor_transform = None
+        self._other_actor_stop_in_front_intersection = 20 # Distance from intersection for leading vehicle to stop
+        self._leading_vehicle_transform = None # Store leading vehicle's initial transform
+
+        # New parameters for added complexity
+        self._pedestrian_start_distance = self._first_vehicle_location + 15 # Pedestrian appears 15m ahead of leading car's start
+        self._parked_vehicle_distance = self._first_vehicle_location + 30 # Parked car appears 30m ahead of leading car's start
+        self._parked_vehicle_lateral_offset = 3.0 # Offset from center of lane for parked car
+
         # Timeout of scenario in seconds
-        self.timeout = timeout
+        self.timeout = timeout if timeout else self.timeout
 
-        super(FollowLeadingVehicle, self).__init__("FollowVehicle",
+        super(FollowLeadingVehicle, self).__init__("FollowVehicleComplex", # Changed scenario name
                                                    ego_vehicles,
                                                    config,
                                                    world,
@@ -76,216 +88,114 @@ class FollowLeadingVehicle(BasicScenario):
 
         if randomize:
             self._ego_other_distance_start = random.randint(4, 8)
-
-            # Example code how to randomize start location
-            # distance = random.randint(20, 80)
-            # new_location, _ = get_location_in_distance(self.ego_vehicles[0], distance)
-            # waypoint = CarlaDataProvider.get_map().get_waypoint(new_location)
-            # waypoint.transform.location.z += 39
-            # self.other_actors[0].set_transform(waypoint.transform)
+            # Further randomization of speeds, distances, pedestrian timing could be added here.
 
     def _initialize_actors(self, config):
         """
-        Custom initialization
+        Custom initialization of leading vehicle, pedestrian, and parked vehicle.
         """
+        # 1. Leading Vehicle
         waypoint, _ = get_waypoint_in_distance(self._reference_waypoint, self._first_vehicle_location)
         transform = waypoint.transform
         transform.location.z += 0.5
         first_vehicle = CarlaDataProvider.request_new_actor('vehicle.nissan.patrol', transform)
         self.other_actors.append(first_vehicle)
+        self._leading_vehicle_transform = transform # Store for potential ActorTransformSetter later if needed
+
+        # 2. Pedestrian
+        ped_waypoint, _ = get_waypoint_in_distance(self._reference_waypoint, self._pedestrian_start_distance)
+
+        # Calculate pedestrian spawn point on the right sidewalk (relative to vehicle's forward direction)
+        ped_spawn_location = ped_waypoint.transform.location
+        # Move pedestrian to the right of the lane, assuming 1.0m for sidewalk
+        ped_spawn_location += ped_waypoint.transform.get_right_vector() * (ped_waypoint.lane_width / 2.0 + 1.0)
+        ped_spawn_location.z += 0.5 # Adjust Z to be on the ground
+
+        ped_transform = carla.Transform(ped_spawn_location, ped_waypoint.transform.rotation)
+        pedestrian = CarlaDataProvider.request_new_actor('walker.pedestrian.0001', ped_transform)
+        self.other_actors.append(pedestrian)
+
+        # 3. Parked Vehicle
+        parked_waypoint, _ = get_waypoint_in_distance(self._reference_waypoint, self._parked_vehicle_distance)
+        # Parked vehicle on the side of the road, slightly obstructing vision/lane
+        parked_transform = carla.Transform(
+            carla.Location(parked_waypoint.transform.location.x,
+                           parked_waypoint.transform.location.y + self._parked_vehicle_lateral_offset, # Offset to the side
+                           parked_waypoint.transform.location.z + 0.1), # Ensure it's on the ground
+            parked_waypoint.transform.rotation
+        )
+        parked_vehicle = CarlaDataProvider.request_new_actor('vehicle.volkswagen.t2', parked_transform)
+        parked_vehicle.set_autopilot(False) # Ensure it doesn't move
+        parked_vehicle.set_simulate_physics(False) # Optional, prevents accidental movement
+        self.other_actors.append(parked_vehicle)
 
-    def _create_behavior(self):
-        """
-        The scenario defined after is a "follow leading vehicle" scenario. After
-        invoking this scenario, it will wait for the user controlled vehicle to
-        enter the start region, then make the other actor to drive until reaching
-        the next intersection. Finally, the user-controlled vehicle has to be close
-        enough to the other actor to end the scenario.
-        If this does not happen within 60 seconds, a timeout stops the scenario
-        """
-
-        # let the other actor drive until next intersection
-        driving_to_next_intersection = py_trees.composites.Parallel(
-            "DrivingTowardsIntersection",
-            policy=py_trees.common.ParallelPolicy.SUCCESS_ON_ONE)
-
-        driving_to_next_intersection.add_child(WaypointFollower(self.other_actors[0], self._first_vehicle_speed))
-        driving_to_next_intersection.add_child(InTriggerDistanceToNextIntersection(
-            self.other_actors[0], self._other_actor_stop_in_front_intersection))
-
-        # stop vehicle
-        stop = StopVehicle(self.other_actors[0], self._other_actor_max_brake)
-
-        # end condition
-        endcondition = py_trees.composites.Parallel("Waiting for end position",
-                                                    policy=py_trees.common.ParallelPolicy.SUCCESS_ON_ALL)
-        endcondition_part1 = InTriggerDistanceToVehicle(self.other_actors[0],
-                                                        self.ego_vehicles[0],
-                                                        distance=20,
-                                                        name="FinalDistance")
-        endcondition_part2 = StandStill(self.ego_vehicles[0], name="StandStill", duration=1)
-        endcondition.add_child(endcondition_part1)
-        endcondition.add_child(endcondition_part2)
-
-        # Build behavior tree
-        sequence = py_trees.composites.Sequence("Sequence Behavior")
-        sequence.add_child(driving_to_next_intersection)
-        sequence.add_child(stop)
-        sequence.add_child(endcondition)
-        sequence.add_child(ActorDestroy(self.other_actors[0]))
-
-        return sequence
-
-    def _create_test_criteria(self):
-        """
-        A list of all test criteria will be created that is later used
-        in parallel behavior tree.
-        """
-        criteria = []
-
-        collision_criterion = CollisionTest(self.ego_vehicles[0])
-
-        criteria.append(collision_criterion)
-
-        return criteria
-
-    def __del__(self):
-        """
-        Remove all actors upon deletion
-        """
-        self.remove_all_actors()
-
-
-class FollowLeadingVehicleWithObstacle(BasicScenario):
-
-    """
-    This class holds a scenario similar to FollowLeadingVehicle
-    but there is an obstacle in front of the leading vehicle
-
-    This is a single ego vehicle scenario
-    """
-
-    timeout = 120            # Timeout of scenario in seconds
-
-    def __init__(self, world, ego_vehicles, config, randomize=False, debug_mode=False, criteria_enable=True):
-        """
-        Setup all relevant parameters and create scenario
-        """
-        self._map = CarlaDataProvider.get_map()
-        self._first_actor_location = 25
-        self._second_actor_location = self._first_actor_location + 41
-        self._first_actor_speed = 10
-        self._second_actor_speed = 1.5
-        self._reference_waypoint = self._map.get_waypoint(config.trigger_points[0].location)
-        self._other_actor_max_brake = 1.0
-        self._first_actor_transform = None
-        self._second_actor_transform = None
-
-        super(FollowLeadingVehicleWithObstacle, self).__init__("FollowLeadingVehicleWithObstacle",
-                                                               ego_vehicles,
-                                                               config,
-                                                               world,
-                                                               debug_mode,
-                                                               criteria_enable=criteria_enable)
-        if randomize:
-            self._ego_other_distance_start = random.randint(4, 8)
-
-    def _initialize_actors(self, config):
-        """
-        Custom initialization
-        """
-
-        first_actor_waypoint, _ = get_waypoint_in_distance(self._reference_waypoint, self._first_actor_location)
-        second_actor_waypoint, _ = get_waypoint_in_distance(self._reference_waypoint, self._second_actor_location)
-        first_actor_transform = carla.Transform(
-            carla.Location(first_actor_waypoint.transform.location.x,
-                           first_actor_waypoint.transform.location.y,
-                           first_actor_waypoint.transform.location.z - 500),
-            first_actor_waypoint.transform.rotation)
-        self._first_actor_transform = carla.Transform(
-            carla.Location(first_actor_waypoint.transform.location.x,
-                           first_actor_waypoint.transform.location.y,
-                           first_actor_waypoint.transform.location.z + 1),
-            first_actor_waypoint.transform.rotation)
-        yaw_1 = second_actor_waypoint.transform.rotation.yaw + 90
-        second_actor_transform = carla.Transform(
-            carla.Location(second_actor_waypoint.transform.location.x,
-                           second_actor_waypoint.transform.location.y,
-                           second_actor_waypoint.transform.location.z - 500),
-            carla.Rotation(second_actor_waypoint.transform.rotation.pitch, yaw_1,
-                           second_actor_waypoint.transform.rotation.roll))
-        self._second_actor_transform = carla.Transform(
-            carla.Location(second_actor_waypoint.transform.location.x,
-                           second_actor_waypoint.transform.location.y,
-                           second_actor_waypoint.transform.location.z + 1),
-            carla.Rotation(second_actor_waypoint.transform.rotation.pitch, yaw_1,
-                           second_actor_waypoint.transform.rotation.roll))
-
-        first_actor = CarlaDataProvider.request_new_actor(
-            'vehicle.nissan.patrol', first_actor_transform)
-        second_actor = CarlaDataProvider.request_new_actor(
-            'vehicle.diamondback.century', second_actor_transform)
-
-        first_actor.set_simulate_physics(enabled=False)
-        second_actor.set_simulate_physics(enabled=False)
-        self.other_actors.append(first_actor)
-        self.other_actors.append(second_actor)
 
     def _create_behavior(self):
         """
-        The scenario defined after is a "follow leading vehicle" scenario. After
-        invoking this scenario, it will wait for the user controlled vehicle to
-        enter the start region, then make the other actor to drive towards obstacle.
-        Once obstacle clears the road, make the other actor to drive towards the
-        next intersection. Finally, the user-controlled vehicle has to be close
-        enough to the other actor to end the scenario.
-        If this does not happen within 60 seconds, a timeout stops the scenario
-        """
-
-        # let the other actor drive until next intersection
-        driving_to_next_intersection = py_trees.composites.Parallel(
-            "Driving towards Intersection",
-            policy=py_trees.common.ParallelPolicy.SUCCESS_ON_ONE)
-
-        obstacle_clear_road = py_trees.composites.Parallel("Obstalce clearing road",
-                                                           policy=py_trees.common.ParallelPolicy.SUCCESS_ON_ONE)
-        obstacle_clear_road.add_child(DriveDistance(self.other_actors[1], 4))
-        obstacle_clear_road.add_child(KeepVelocity(self.other_actors[1], self._second_actor_speed))
-
-        stop_near_intersection = py_trees.composites.Parallel(
-            "Waiting for end position near Intersection",
-            policy=py_trees.common.ParallelPolicy.SUCCESS_ON_ONE)
-        stop_near_intersection.add_child(WaypointFollower(self.other_actors[0], 10))
-        stop_near_intersection.add_child(InTriggerDistanceToNextIntersection(self.other_actors[0], 20))
-
-        driving_to_next_intersection.add_child(WaypointFollower(self.other_actors[0], self._first_actor_speed))
-        driving_to_next_intersection.add_child(InTriggerDistanceToVehicle(self.other_actors[1],
-                                                                          self.other_actors[0], 15))
-
-        # end condition
+        The scenario defined after is an enhanced "follow leading vehicle" scenario.
+        It integrates a pedestrian crossing and a parked vehicle.
+        """
+
+        # 1. Leading vehicle drives, potentially reacting to pedestrian
+        leading_vehicle_driving = py_trees.composites.Parallel(
+            "LeadingVehicleDrivingAndPedestrianCrossing",
+            policy=py_trees.common.ParallelPolicy.SUCCESS_ON_ALL)
+
+        # Leading vehicle follows waypoints
+        leading_vehicle_follower = WaypointFollower(self.other_actors[0], self._first_vehicle_speed) # self.other_actors[0] is leading vehicle
+        
+        # Pedestrian crosses the road (self.other_actors[1])
+        # Calculate target location for pedestrian on the left sidewalk
+        ped_waypoint_for_crossing, _ = get_waypoint_in_distance(self._reference_waypoint, self._pedestrian_start_distance)
+        ped_target_location = ped_waypoint_for_crossing.transform.location
+        # Move pedestrian to the left of the lane, assuming 1.0m for sidewalk
+        ped_target_location -= ped_waypoint_for_crossing.transform.get_right_vector() * (ped_waypoint_for_crossing.lane_width / 2.0 + 1.0)
+        ped_target_location.z += 0.5
+
+        pedestrian_cross_behavior = WalkToLocation(self.other_actors[1], ped_target_location)
+        
+        # Introduce a delay for pedestrian to start crossing AFTER leading vehicle has started moving.
+        pedestrian_start_sequence = py_trees.composites.Sequence("PedestrianStartSequence")
+        pedestrian_start_sequence.add_child(TimeOut(5)) # Wait 5 seconds after scenario start
+        pedestrian_start_sequence.add_child(pedestrian_cross_behavior)
+
+        # Leading vehicle drives while the pedestrian sequence is active.
+        # Carla's AI for vehicles should automatically react to the pedestrian.
+        leading_vehicle_driving.add_child(leading_vehicle_follower)
+        leading_vehicle_driving.add_child(pedestrian_start_sequence)
+
+        # Wait for leading vehicle to be close to the intersection to decide to stop (its final stop)
+        leading_vehicle_at_intersection_trigger = InTriggerDistanceToNextIntersection(
+            self.other_actors[0], self._other_actor_stop_in_front_intersection
+        )
+        
+        # Sequence for the leading vehicle's overall journey: drive, reach intersection, then stop
+        leading_vehicle_overall_journey = py_trees.composites.Sequence("LeadingVehicleJourney")
+        leading_vehicle_overall_journey.add_child(leading_vehicle_driving) # Includes pedestrian interaction
+        leading_vehicle_overall_journey.add_child(leading_vehicle_at_intersection_trigger)
+        leading_vehicle_overall_journey.add_child(StopVehicle(self.other_actors[0], self._other_actor_max_brake)) # Stops at intersection
+
+        # 2. End condition for Ego Vehicle
+        # The ego vehicle must stop close enough to the leading vehicle and stand still.
         endcondition = py_trees.composites.Parallel("Waiting for end position",
                                                     policy=py_trees.common.ParallelPolicy.SUCCESS_ON_ALL)
-        endcondition_part1 = InTriggerDistanceToVehicle(self.other_actors[0],
+        endcondition_part1 = InTriggerDistanceToVehicle(self.other_actors[0], # Leading vehicle
                                                         self.ego_vehicles[0],
-                                                        distance=20,
+                                                        distance=10, # Reduced distance for tighter following
                                                         name="FinalDistance")
-        endcondition_part2 = StandStill(self.ego_vehicles[0], name="FinalSpeed", duration=1)
+        endcondition_part2 = StandStill(self.ego_vehicles[0], name="StandStill", duration=2) # Increased duration for stand still
         endcondition.add_child(endcondition_part1)
         endcondition.add_child(endcondition_part2)
 
-        # Build behavior tree
-        sequence = py_trees.composites.Sequence("Sequence Behavior")
-        sequence.add_child(ActorTransformSetter(self.other_actors[0], self._first_actor_transform))
-        sequence.add_child(ActorTransformSetter(self.other_actors[1], self._second_actor_transform))
-        sequence.add_child(driving_to_next_intersection)
-        sequence.add_child(StopVehicle(self.other_actors[0], self._other_actor_max_brake))
-        sequence.add_child(TimeOut(3))
-        sequence.add_child(obstacle_clear_road)
-        sequence.add_child(stop_near_intersection)
-        sequence.add_child(StopVehicle(self.other_actors[0], self._other_actor_max_brake))
+        # Build overall behavior tree
+        sequence = py_trees.composites.Sequence("ComplexFollowVehicleBehavior")
+        sequence.add_child(leading_vehicle_overall_journey)
         sequence.add_child(endcondition)
-        sequence.add_child(ActorDestroy(self.other_actors[0]))
-        sequence.add_child(ActorDestroy(self.other_actors[1]))
+        
+        # Clean up all actors at the end
+        sequence.add_child(ActorDestroy(self.other_actors[0], name="DestroyLeadingVehicle"))
+        sequence.add_child(ActorDestroy(self.other_actors[1], name="DestroyPedestrian"))
+        sequence.add_child(ActorDestroy(self.other_actors[2], name="DestroyParkedVehicle")) # self.other_actors[2] is parked vehicle
 
         return sequence
 
@@ -297,6 +207,10 @@ class FollowLeadingVehicleWithObstacle(BasicScenario):
         criteria = []
 
         collision_criterion = CollisionTest(self.ego_vehicles[0])
+        # Additional criteria could be added here, e.g.,
+        #   - OffRoadTest: if the parked car forces the ego off the road.
+        #   - RunningRedLightTest: if there's an intersection with a traffic light.
+        #   - DrivenDistanceTest: to ensure progress.
 
         criteria.append(collision_criterion)
 
@@ -306,4 +220,4 @@ class FollowLeadingVehicleWithObstacle(BasicScenario):
         """
         Remove all actors upon deletion
         """
-        self.remove_all_actors()
+        self.remove_all_actors()
\ No newline at end of file
